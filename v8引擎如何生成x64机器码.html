<html>
<head>
	<title>V8 引擎如何生成 X64 机器码-以浮点数加法为例</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no">
	<meta content="telephone=no" name="format-detection">
	<meta name="apple-touch-fullscreen" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<link href="./assets/x.png" rel="shortcut icon" type="image/x-icon">
	<link rel="stylesheet" href="./css/reset.css">
</head>
<body>
	<div class="content">
		<h2>V8 引擎如何生成X64机器码</h2>
		<h3 style="text-align: center;font-size: 16px;"><b style="transform: scaleX(2);display: inline-block;transform-origin: right;">—</b>以浮点数加法为例</h3>
		<h3>摘要</h3>
		<div>
			本文将主要从以下 3 个方面介绍V8引擎是如何在 Intel X64 平台下生成浮点数加法机器码的。首先，简要介绍一下 V8 引擎；然后，从 C 语言和 X64 汇编的角度举例说明为什么浮点数相加不精确；最后，查看 V8 中生成浮点数加法机器码的源码。
		</div>
		<h3>v8简介</h3>
		<div>
			V8 是一个由 Google 开源的高性能 JavaScript 和 WebAssembly 引擎，其源代码使用 C++ 编写。V8 被用于 Google 的开源浏览器 Chrome 中，同时也被用于 Node.js，以及其他一些软件中。V8 实现了 ECMAScript 和 WebAssembly 标准，可以运行在 Windows 7 及以上，macOS 10.12+，以及 x64、IA-32、ARM、MIPS 架构的 Linux 系统。V8 可以独立运行，也可以被嵌入到 C++ 应用程序中。
		</div>
		<div><a href="https://cs.chromium.org/chromium/src/v8/?g=0" target="_blank">V8 源码</a>可在浏览器中查看，这个源码浏览网站功能十分强大，可以非常快速的查看变量定义、引用和 C++ 类的继承关系。缺点是不能查看 V8 某个版本或某个git tag的源码，但依然强烈推荐。如果想要查看 V8 指定版本的代码，可以访问<a href="https://chromium.googlesource.com/v8/v8.git" "_blank"> v8.git </a>。如果想要本地编译成功，在参考<a href="https://v8.dev/docs/build-gn" target="_blank"> V8 官方文档</a>的基础上，要尤其注意墙的问题，浏览器能访问google不代表终端也能访问google，第一次编译成功花了耗费了我两个星期的时间。</div>
		<div>
			以V8 7.7.0版本为例，源码目录结构如下：
		</div>
		<img src="./assets/v8-folder.png" alt="V8 源码">
		<div>
			有10+个文件夹，存放源码的文件夹为 src 和 third_party，做为一个前端，我们真正关心的源码位于 src 目录，其它目录粗略概述如下：
		</div>
		<ul>
			<li>测试：benchmarks、test、testing、infra</li>
			<li>C++项目 项目嵌入 V8 ：include、samples</li>
			<li>编译构建：build、build_overrides、buildtools、gni</li>
			<li>文档：docs，实际上文件夹下除了一个链接<a href="https://v8.dev/docs" target="_blank"> https://v8.dev/docs </a>外，其它内容可忽略</li>
			<li>V8 编译成功后生成的文件：out</li>
			<li>工具：tools</li>
			<li>其它：base文件夹下只有几百行代码，具体作用不详，custom_deps文件夹下几乎没有内容</li>
		</ul>
		<div>
			src 文件夹目录如下：
		</div>
		<img src="./assets/v8-src-folder.png" alt="V8 源码">
		<div>
			V8 编译 JS 代码流程如下：
		</div>
		<img src="./assets/v8-overview.png" alt="V8 概览">
		<div>
			parser 将 JS 代码转换成 AST ，此处源码位于 src/parsing 和 src/ast 文件夹下。interpreter 将 AST 生成字节码，执行。在这个阶段，JS 代码处于解释执行。
			此处源码位于 src/interpreter。当一段代码被执行多次变成热点代码时，V8 optimizing compiler会将字节码生成机器码。此处源码位于 src/compiler 和 src/codegen。
		</div>
		<div>
			V8 早期版本是从 AST 直接生成机器码，这种方法的缺点是机器码比较占内存，而且有些代码只会执行一次，比如做业务需求时经常见到的：
		</div>
		<pre>
	function init () {
		var app = new Vue({
		  	el: '#app',
		  	data: {
		  		XXX: YYY
		  	}
		})
	}</pre>
		<div>
			在一个前端页面里，这段代码只会执行一次，如果没有解释器，这段代码会走过一个完整的编译流程被编译成机器码，执行。做为Vue框架的使用者，我们知道这段代码只会被执行一次，但 V8 并不知道。机器码还会继续占用内存。所以在2016年，V8 开始引入解释器 Ignition。
		</div>
		<h3>为什么 JS 浮点数运算不精确</h3>
		<div>网络上相关的文章非常多，浮点数运算不精确的语言不只 JS，C/C++/Java/Python/Matlab/Delphi/VB 做浮点数运算也不精确，甚至用汇编做浮点数运算也不精确。如以下 C 代码：</div>
		<pre>
	#include &lt;stdio.h&gt;
	#include &lt;math.h&gt;
	int main() {
	    double a = pow(2, 100);
	    double b = pow(2, 47);
	    double c = pow(2, 48);
	    double d = a + b;
	    double e = a + c;
	    printf("a == d is %d\n", a == d);
	    printf("a == e is %d\n", a == e);
	}</pre>
		<div>在 Xcode 中运行结果如下：</div>
		<div>为什么为是这样的结果呢？因为计算机中浮点数表示有 IEEE 754标准，标准中的浮点数表示如下：</div>
		<img src="./assets/double-memory.png" alt="浮点数表示">
		<div>双精度浮点数在内存中可分为3部分：</div>
		<div>第一部分为符号位，占1bit，负数为1，正数为0。</div>
		<div>第二部分为指数域，占11bit，指数域的值为 1023 + 指数。</div>
		<div>第三部分为尾数域，占52bit，表示小数，本文暂不涉及。</div>
		<div>以<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super">100</span></span>为例，使用科学计数法表示为 1 &times;<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super">100</span></span>。根据 IEEE 754 标准：</div>
		<div>第一部分符号位为0。</div>
		<div>第二部分为 1023 + 100 ，结果为 1123，使用 JS 的 Number.prototype.toString 方法，得到 1123 的 16 进制表示为 0x463。代码如下：</div>
		<pre>
	num = 1123;
	num.toString(16);
		</pre>
		<div>由于没有小数，第三部分全是0；</div>
		<div>综合起来，<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super">100</span></span>在内存中的表示为 0x4630000000000000 ，这一点可以在 Xcode 中证实。</div>
		<img src="./assets/view-memory.png" alt="">
		<div>没有 Xcode 也没关系，可以在<a href="https://tool.lu/coderunner/" target="_blank"> https://tool.lu/coderunner/ </a>编辑运行以上 C 代码</div>
		<img src="./assets/c-double.png" alt="Xcode C">
		<div>那么为什么 a == d 呢？</div>
		<div>
			若<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super" style="left: -12px;">47</span></span>与<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super">100</span></span>相加，由于二者指数不一样，前者需求移位，与后者的指数对齐，表示成 <span class="pr"> 2 &nbsp;&nbsp;<span class="super" style="left: -20px;">-53</span></span> &times; <span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super" style="left: -21px;">100</span></span>的形式。由于 IEEE 754 标准表示小数尾数域只有 52bit，<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super" style="left: -12px;">47</span></span>的小数有 53bit，且这 53bit 里面前 52位高 bit 都是0，最低 bit 位才是1，直接舍弃。<span class="pr"> 2 &nbsp;&nbsp;&nbsp;<span class="super" style="left: -12px;">47</span></span>经过移位后变成了0。所以 a == d。
		</div>
		<h3>V8 是如何生成浮点数加法的机器码的</h3>
		<div>通过查看上一段 C 代码生成的 X64 汇编和 Intel 软件手册可知，X64 平台浮点数加法指令为 addsd 或 vaddsd。</div>
		<img src="./assets/xcode-addsd.png" alt="addsd">
		<img src="./assets/intel-addsd.png" alt="addsd">
	</div>
</body>
</html>